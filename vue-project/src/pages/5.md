다섯번째 포스트
https://cdn.pixabay.com/photo/2016/01/20/13/05/cat-1151519_1280.jpg
예제 포스트로 고양이가 참 귀엽습니다.

# algorithm

알고리즘 공부.

모든 코드는 직접 손으로 타이핑.

의사 코드 = 수도 코드

순서도도 활용 가능하나 복잡해지면 사용하기 힘들다.

의사 코드에서 중요한건 `명확성`!!!

의사 코드와 주석은 별개이다. 의사 코드는 꼭 필요한 부분만 명확하게 표현하자.

예시)
쇼핑 카트에 객체가 있는 상태를 수도 코드로 표현하자.

1. 시작 지점을 알려주면 좋을 듯.
2. 객체가 값을 가지고 있다.
3. 객체의 값만 더해서 출력하고 싶다.
4. total이라는 값을 0으로 초기화
5. 쇼핑카트의 모든 요소의 대해 반복
5. 반복하면서 total += 요소의 값
6. 다 더하면 반복 종료
7. 출력(total)
8. 종료

![alt text](images/image.png)

이렇게 표현 가능.

## 알고리즘 성능
- APS 과정의 목표 중의 하나는 보다 좋은 알고리즘을 이해하고 활용하는 것이다.
- 무엇이 좋은 알고리즘인가?
    - 정확성 : 가장 먼저 지키고
    - 확장성 : 두 번째로 지켜지면
    - 효율성 : 그 다음에 시도하고
    - 단순성 : 정리한다.

- 이유
> 주어진 문제를 해결하기 위해 여러 개의 다양한 알고리즘이 가능. 일단 해결하고 최적화가 적합함.
 -> 그렇다면 어떤 알고리즘을 사용해야 하는가? -> 알고리즘의 성능을 분석해보자.

알고리즘의 성능 분석 필요
> 작업량을 계산해본다.

![alt text](images/image-1.png)

이런 식으로 같은 계산도 방법에 따라 작업량이 달라진다.

이런 작업량을 복잡도라고 표현한다.

## 복잡도
복잡도에는 시간 복잡도와 공간 복잡도가 있따.

### 시간 복잡도
연산의 작업량과 수행 시간을 판단

세 가지 관점에서 본다.
1. 최선의 경우 (Best Case)
2. 평균의 경우 (Average Case)
3. 최악의 경우 (Worst Case)

### 공간 복잡도
메모리의 사용량을 의미

보통의 경우 시간 복잡도에서 문제가 발생한다.

복잡도는 점근적 표기를 활용한다.

점근적 표기 : 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법

![alt text](images/image-2.png)

### 빅-오 표기법
점근적 표기법 중 가장 큰 영향력을 주는 n에 대한 항만을 표시 & 계수는 생략

![alt text](images/image-3.png)

시간 복잡도 별 실제 실행 시간 비교

![alt text](images/image-4.png)

\+ log는 밑이 2라고 생각해야 한다.

---
우리는 완전 검색에 대해서 알아볼 것이다.

## 재귀 호출
함수를 재귀 형식으로 만드는 것이다.

재귀란? (recursion) : 자기 자신을 호출하는 것을 의미한다.

반복과 재귀는 비슷하다.

차이점
> 반복은 수행하는 작업이 완료될 때까지 반복
> 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법

### 재귀 함수
> - 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수
> - 기본 부분과 유도 부분으로 구성됨
> - 반복문에 비해 간결하고 이해하기 쉽다.
> - 함수 호출이 스택 구조로 진행된다.

중요한건 기본 부분을 정의하고 유도 부분으로 기본 부분까지 도달할 수 있게 만드는 것이다.

예시 1) 팩토리얼을 재귀 함수로 만든다면

*Basis Rule*
    N <= 1 이면, n=1

*Inductive Rule*
    N > 1, N! = N * (N - 1)!

이를 통해 재귀 함수를 만들어 보면 다음과 같다.
```python
def fact(n):
    if n <= 1:
        return 1
    else:
        return n * fact(n-1)
```

예시 2) 피보나치 수열 재귀 호출

피보나치 수열 : 이전 두 수 합을 다음 항으로 하는 수열

```python
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)
```

예시 3) 하노이의 탑

- 제약 사항
    - 원판 번호는 맨 위부터 1,2,3 순으로 부여
    - 기둥은 3개로 가정
    - 시작은 N 개의 원판이 1번 기둥에 쌓여 있다.

- 입력
    - 원판 개수인 N을 입력받는다. (1 <= N <= 10)
    - 원판 번호는 맨 위부터 1,2,3 순으로 부여

- 출력
    - 옮겨지는 원판 번호 : 출발 기둥 번호 -> 목적 기둥 번호

규칙 찾기
[ ] 원판이 1개 일 때
1. A에서 원판 1을 C로 이동

[ ] 원판이 2개 일 때
1. A에서 원판 1을 B로 이동
2. A에서 원판 2를 C로 이동
3. A에서 원판 1을 C로 이동

[ ] 원판이 3개 일 때
1. A에서 원판 1을 C로 이동
2. A에서 원판 2를 B로 이동
3. C에서 원판 1을 B로 이동
4. A에서 원판 3을 C로 이동
5. B에서 원판 1을 A로 이동
6. B에서 원판 2를 C로 이동
7. A에서 원판 1을 C로 이동

이런 문제를 풀다보면 주로 하는 실수가 있다.
바로 효율적인 알고리즘을 적용하려고 시도하는 것이다.
이러면 실수하기 너무 쉽다.

## 일단 정확성 부터 챙기자. = 완전 탐색

### 완전 검색
문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법

Brute-force 혹은 generate-and-test 기법이라고 불린다.
    
- Just do it

- force는 사람(지능)보다는 컴퓨터의 force를 의미함.

수행 속도는 느리나, 해답을 찾지 못할 확률이 `낮다`.

### Baby-gin Game
- 0~9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적인 번호를 갖는 경우를 run이라고 하고, 3장의 카드가 같은 번호를 갖는 경우를 triplet이라고 한다.
- 그리고, 6장의 카드가 run과 triplet으로만 구성된 경우를 baby-gin으로 부른다.
- 6자리의 숫자를 입력받아 baby-gin 여부를 판단하는 프로그램을 작성하라.

보통 이런 문제를 받으면 처음에는 정렬을 시도한다. 하지만 정렬은 적합한 방법이 아니다.

예를 들어 {1,2,3,1,2,3} 이런 값이 주어진다면 triplet이 2개로 baby-gin 이지만 정렬을 하게 되면

{1,1,2,2,3,3}으로 run도 triplet도 확인하기 힘들어진다.

가장 손쉬운 방법은 경우의 수를 전부 해보는 것이다.


## 여행 계획 문제 시리즈

![alt text](images/image-5.png)

![alt text](images/image-6.png)

![alt text](images/image-7.png)

이를 해결하는 가장 쉬운 방법 = 순열

## 순열 (Permutation)

![alt text](images/image-8.png)

## 조합 (Combination)

순열과 조합의 차이점은 중복을 허용하냐 안하냐의 차이점.

## 중복 순열

순서를 고려하여 여러 번 선택할 수 있게 나열하는 모든 가능한 방법
